local NiceFill = {}

NiceFill.surface_prefix = "NiceFill_"
NiceFill.replaceable_tiles = {"water", "deepwater", "water-green", "deepwater-green"}

if(script.active_mods['space-age']) then
	merge(NiceFill.replaceable_tiles, {
		"water-mud",
		"water-shallow",
		"wetland-light-green-slime",
		"wetland-green-slime",
		"wetland-light-dead-skin",
		"wetland-dead-skin",
		"wetland-pink-tentacle",
		"wetland-red-tentacle",
		"wetland-yumako",
		"wetland-jellynut",
		"wetland-blue-slime",
		"gleba-deep-lake",
	})
end

-- require('util')

---@param surface LuaSurface
function NiceFill.get_surface_name(surface)
	if(string.starts(surface.name, NiceFill.surface_prefix)) then
		return surface.name
	end

	return NiceFill.surface_prefix .. surface.name
end

---@param surface LuaSurface
---@return LuaSurface?
function NiceFill.get_surface(surface)
	local nicefill_name = NiceFill.get_surface_name(surface)
	return game.get_surface(nicefill_name)
end

---@param surface LuaSurface?
---@param tiles Tile[]
function NiceFill.validate_surface(surface, tiles)
	-- When a nil value is passed it means the surface doesn't exist, so validation isn't necessary
	if(surface == nil) then return end

	-- Validating surfaces other than those created by NiceFill isn't necessary
	if(not string.starts(surface.name, NiceFill.surface_prefix)) then return end

	-- At this point we're validating a surface generated by NiceFill

	for _, tile in pairs(tiles) do
		if not surface.is_chunk_generated( { x = (tile.position.x / 32), y = (tile.position.y / 32) } ) then
			surface.request_to_generate_chunks( tile.position, 0 )
		end
	end

	surface.force_generate_chunk_requests()

	for _, tile in pairs(tiles) do
		local nice_tile = surface.get_tile( tile.position.x, tile.position.y )

		if DEBUG then log(serpent.block( nice_tile.name )) end

		if(has_value(NiceFill.replaceable_tiles, nice_tile.name)) then
			log(string.format(
				'NiceFill surface "%s" contains an invalid tile "%s" at position {%f, %f}',
				surface.name,
				nice_tile.name,
				math.floor(tile.position.x),
				math.floor(tile.position.y)
			))

			game.delete_surface(surface)
			return
		end
	end
end

function NiceFill.delete_legacy_surfaces()
	local names = {"NiceFill"}

	for _, name in pairs(names) do
		if game.get_surface(name) ~= nil then
			game.delete_surface(name)
		end
	end
end


return NiceFill